"""Unit tests for ExploitAgent.

Tests cover:
- Exploit chain suggestion for different vulnerability types
- Approval workflow integration (approve/deny/modify)
- Blast radius display
- Evidence validation
- PoC generation
- Audit logging
- Safe step auto-execution
"""

import pytest
from unittest.mock import AsyncMock, MagicMock, patch
from datetime import datetime

from scanner.agents.exploit import (
    ExploitAgent,
    ExploitChain,
    ExploitStep,
    ExploitResult,
)
from scanner.core.llm.tools import RiskLevel
from scanner.core.output import Evidence, Finding, SourceType
from scanner.core.safety.approval import ApprovalDecision


# Test Fixtures

@pytest.fixture
def exploit_agent():
    """Create ExploitAgent instance for testing."""
    agent = ExploitAgent(session_id="test-session-exploit")
    # Mock the audit method to avoid database calls
    agent.audit = AsyncMock()
    return agent


@pytest.fixture
def sqli_finding():
    """Create a SQL injection finding for testing."""
    return Finding(
        title="SQL Injection in id parameter",
        severity="critical",
        description="The id parameter is vulnerable to SQL injection",
        evidence=[
            Evidence(
                source=SourceType.TOOL_CONFIRMED,
                data={"parameter": "id", "method": "GET"},
                tool_name="sqlmap"
            )
        ],
        confidence="high"
    )


@pytest.fixture
def xss_finding():
    """Create an XSS finding for testing."""
    return Finding(
        title="Reflected XSS in search parameter",
        severity="medium",
        description="The search parameter reflects user input without encoding",
        evidence=[
            Evidence(
                source=SourceType.TOOL_CONFIRMED,
                data={"parameter": "q", "method": "GET"},
                tool_name="xsstrike"
            )
        ],
        confidence="medium"
    )


@pytest.fixture
def cmd_injection_finding():
    """Create a command injection finding for testing."""
    return Finding(
        title="Command Injection in host parameter",
        severity="critical",
        description="The host parameter allows OS command injection",
        evidence=[
            Evidence(
                source=SourceType.TOOL_CONFIRMED,
                data={"parameter": "host", "method": "POST"},
                tool_name="commix"
            )
        ],
        confidence="high"
    )


@pytest.fixture
def header_finding():
    """Create a security header finding for testing."""
    return Finding(
        title="Missing X-Frame-Options header",
        severity="low",
        description="The X-Frame-Options header is not set",
        evidence=[
            Evidence(
                source=SourceType.TOOL_CONFIRMED,
                data={"header": "X-Frame-Options", "present": False},
                tool_name="security_headers"
            )
        ],
        confidence="high"
    )


# Chain Suggestion Tests

@pytest.mark.asyncio
async def test_exploit_suggest_sqli_chain(exploit_agent, sqli_finding):
    """Test that SQLi finding generates 3-step chain with correct risk levels."""
    chain = await exploit_agent._suggest_chain(sqli_finding)

    assert isinstance(chain, ExploitChain)
    assert chain.finding == sqli_finding
    assert len(chain.steps) == 3
    assert "SQL injection" in chain.objective

    # Verify step risk levels
    assert chain.steps[0].risk_level == RiskLevel.SAFE  # Verify
    assert chain.steps[1].risk_level == RiskLevel.MODERATE  # Extract schema
    assert chain.steps[2].risk_level == RiskLevel.DESTRUCTIVE  # Dump data

    # Verify tool names
    assert all(step.tool_name == "sqlmap" for step in chain.steps)

    # Verify blast radius descriptions exist
    assert all(step.blast_radius for step in chain.steps)
    assert all(step.affected_systems for step in chain.steps)


@pytest.mark.asyncio
async def test_exploit_suggest_xss_chain(exploit_agent, xss_finding):
    """Test that XSS finding generates appropriate exploitation chain."""
    chain = await exploit_agent._suggest_chain(xss_finding)

    assert isinstance(chain, ExploitChain)
    assert chain.finding == xss_finding
    assert len(chain.steps) == 3
    assert "XSS" in chain.objective

    # Verify risk levels (reflected XSS)
    assert chain.steps[0].risk_level == RiskLevel.SAFE  # Verify reflection
    assert chain.steps[1].risk_level == RiskLevel.SAFE  # Craft payload
    assert chain.steps[2].risk_level == RiskLevel.MODERATE  # Test payload

    # Verify tool names
    assert all(step.tool_name == "xsstrike" for step in chain.steps)


@pytest.mark.asyncio
async def test_exploit_suggest_cmd_injection_chain(exploit_agent, cmd_injection_finding):
    """Test that command injection finding generates 2-step chain."""
    chain = await exploit_agent._suggest_chain(cmd_injection_finding)

    assert isinstance(chain, ExploitChain)
    assert len(chain.steps) == 2
    assert "command injection" in chain.objective.lower()

    # Verify risk levels
    assert chain.steps[0].risk_level == RiskLevel.SAFE  # Verify with whoami
    assert chain.steps[1].risk_level == RiskLevel.DESTRUCTIVE  # Execute PoC command

    assert all(step.tool_name == "commix" for step in chain.steps)


@pytest.mark.asyncio
async def test_exploit_suggest_header_chain(exploit_agent, header_finding):
    """Test that header finding generates single SAFE verification step."""
    chain = await exploit_agent._suggest_chain(header_finding)

    assert isinstance(chain, ExploitChain)
    assert len(chain.steps) == 1
    assert chain.steps[0].risk_level == RiskLevel.SAFE
    assert chain.steps[0].reversible is True


# Approval Workflow Tests

@pytest.mark.asyncio
async def test_exploit_approval_approve(exploit_agent, sqli_finding):
    """Test that approved steps execute successfully."""
    chain = await exploit_agent._suggest_chain(sqli_finding)
    moderate_step = chain.steps[1]  # Extract schema step

    # Mock approval to return APPROVE
    with patch('scanner.agents.exploit.request_approval') as mock_approval:
        mock_approval.return_value = (ApprovalDecision.APPROVE, moderate_step.tool_params)

        with patch('scanner.agents.exploit.get_session') as mock_session:
            mock_session.return_value.__aenter__.return_value = MagicMock()

            result = await exploit_agent._execute_step(moderate_step)

            # Verify approval was requested
            mock_approval.assert_called_once()
            assert "status" in result
            assert result.get("status") == "success"


@pytest.mark.asyncio
async def test_exploit_approval_deny(exploit_agent, sqli_finding):
    """Test that denied steps return error and don't execute."""
    chain = await exploit_agent._suggest_chain(sqli_finding)
    destructive_step = chain.steps[2]  # Dump data step

    # Mock approval to return DENY
    with patch('scanner.agents.exploit.request_approval') as mock_approval:
        mock_approval.return_value = (ApprovalDecision.DENY, {})

        with patch('scanner.agents.exploit.get_session') as mock_session:
            mock_session.return_value.__aenter__.return_value = MagicMock()

            result = await exploit_agent._execute_step(destructive_step)

            # Verify denial was processed
            assert "error" in result
            assert result["error"] == "User denied approval"


@pytest.mark.asyncio
async def test_exploit_chain_stops_on_deny(exploit_agent, sqli_finding):
    """Test that exploit chain stops when user denies a step."""
    # Mock approval to deny the second step
    with patch('scanner.agents.exploit.request_approval') as mock_approval:
        mock_approval.return_value = (ApprovalDecision.DENY, {})

        with patch('scanner.agents.exploit.get_session') as mock_session:
            mock_session.return_value.__aenter__.return_value = MagicMock()

            results = await exploit_agent.execute([sqli_finding])

            assert len(results) == 1
            result = results[0]

            # Should execute step 1 (SAFE auto-execute), deny step 2, stop before step 3
            assert result.steps_executed == 1  # Only first SAFE step
            assert result.steps_total == 3
            # Note: Evidence IS validated because step 1 has successful tool output
            # This is correct behavior - even partial chain can provide evidence
            assert result.evidence_validated is True
            assert result.confidence == "confirmed"
            assert result.poc is not None  # PoC generated from step 1


@pytest.mark.asyncio
async def test_exploit_safe_steps_auto_execute(exploit_agent, sqli_finding):
    """Test that SAFE steps don't go through approval workflow."""
    chain = await exploit_agent._suggest_chain(sqli_finding)
    safe_step = chain.steps[0]  # Verify step

    # Should not call request_approval for SAFE steps
    with patch('scanner.agents.exploit.request_approval') as mock_approval:
        result = await exploit_agent._execute_step(safe_step)

        # Approval should NOT be requested for SAFE steps
        mock_approval.assert_not_called()
        assert result.get("status") == "success"


# Blast Radius Display Tests

@pytest.mark.asyncio
async def test_exploit_blast_radius_displayed(exploit_agent, sqli_finding):
    """Test that blast radius information is displayed to user."""
    chain = await exploit_agent._suggest_chain(sqli_finding)
    step = chain.steps[1]  # Moderate step

    # Capture click.echo output
    with patch('scanner.agents.exploit.click.echo') as mock_echo:
        exploit_agent._display_blast_radius(step, 2, 3)

        # Verify blast radius components were displayed
        call_args = [str(call) for call in mock_echo.call_args_list]
        output = " ".join(call_args)

        assert "Step 2/3" in output
        assert "Risk Level:" in output
        assert "MODERATE" in output
        assert "Blast Radius:" in output
        assert "Affected Systems:" in output
        assert "Reversible:" in output


# Evidence Validation Tests

def test_exploit_evidence_validated_success(exploit_agent):
    """Test that evidence validation passes with good tool output."""
    results = [
        {
            "status": "success",
            "vulnerable": True,
            "raw_output": "sqlmap identified injection point: Parameter id (GET)"
        },
        {
            "status": "success",
            "schema": ["users", "posts"],
            "raw_output": "Database enumeration successful"
        }
    ]

    validated = exploit_agent._validate_evidence(results)
    assert validated is True


def test_exploit_evidence_validated_failure(exploit_agent):
    """Test that evidence validation fails with empty output."""
    results = [
        {
            "status": "success",
            "raw_output": ""  # Empty output
        },
        {
            "status": "success",
            "vulnerable": False  # No positive indicators
        }
    ]

    validated = exploit_agent._validate_evidence(results)
    assert validated is False


def test_exploit_evidence_no_tool_output(exploit_agent):
    """Test that evidence validation fails when tool returns errors."""
    results = [
        {
            "status": "error",
            "error": "Connection timeout",
            "raw_output": None
        }
    ]

    validated = exploit_agent._validate_evidence(results)
    assert validated is False


def test_exploit_evidence_empty_results(exploit_agent):
    """Test that evidence validation fails with no results."""
    validated = exploit_agent._validate_evidence([])
    assert validated is False


def test_exploit_evidence_success_indicators(exploit_agent):
    """Test that evidence validation checks for specific success indicators."""
    # Test various success indicator keys
    success_cases = [
        {"status": "success", "vulnerable": True, "raw_output": "test"},
        {"status": "success", "injectable": True, "raw_output": "test"},
        {"status": "success", "reflected": True, "raw_output": "test"},
        {"status": "success", "executed": True, "raw_output": "test"},
        {"status": "success", "schema": ["table1"], "raw_output": "test"},
        {"status": "success", "data": {"key": "value"}, "raw_output": "test"},
        {"status": "success", "command_output": "uid=33", "raw_output": "test"},
        {"status": "success", "verified": True, "raw_output": "test"},
    ]

    for result in success_cases:
        validated = exploit_agent._validate_evidence([result])
        assert validated is True, f"Should validate with {list(result.keys())}"


# PoC Generation Tests

@pytest.mark.asyncio
async def test_exploit_poc_generated(exploit_agent, sqli_finding):
    """Test that PoC is generated for validated exploits."""
    chain = await exploit_agent._suggest_chain(sqli_finding)
    results = [
        {
            "status": "success",
            "vulnerable": True,
            "raw_output": "SQL injection confirmed"
        },
        {
            "status": "success",
            "schema": ["users"],
            "raw_output": "Schema extracted"
        }
    ]

    poc = exploit_agent._generate_poc(chain, results)

    assert poc is not None
    assert isinstance(poc, str)
    assert "SQL Injection" in poc
    assert "sqlmap" in poc.lower()
    assert "```" in poc  # Markdown code block


@pytest.mark.asyncio
async def test_exploit_poc_not_generated_unvalidated(exploit_agent, sqli_finding):
    """Test that PoC is NOT generated when evidence isn't validated."""
    chain = await exploit_agent._suggest_chain(sqli_finding)
    results = [
        {
            "status": "error",
            "error": "Connection failed"
        }
    ]

    poc = exploit_agent._generate_poc(chain, results)

    assert poc is None


@pytest.mark.asyncio
async def test_exploit_poc_xss(exploit_agent, xss_finding):
    """Test XSS PoC generation."""
    chain = await exploit_agent._suggest_chain(xss_finding)
    results = [
        {"status": "success", "reflected": True, "raw_output": "Reflected"},
        {"status": "success", "payload": "<script>alert(1)</script>", "raw_output": "Payload crafted"},
        {"status": "success", "executed": True, "raw_output": "Executed"}
    ]

    poc = exploit_agent._generate_poc(chain, results)

    assert poc is not None
    assert "XSS" in poc
    assert "<script>" in poc
    assert "alert" in poc.lower()


@pytest.mark.asyncio
async def test_exploit_poc_cmd_injection(exploit_agent, cmd_injection_finding):
    """Test command injection PoC generation."""
    chain = await exploit_agent._suggest_chain(cmd_injection_finding)
    results = [
        {"status": "success", "injectable": True, "raw_output": "Command injection confirmed"},
        {"status": "success", "command_output": "uid=33", "raw_output": "Command executed"}
    ]

    poc = exploit_agent._generate_poc(chain, results)

    assert poc is not None
    assert "Command Injection" in poc
    assert "curl" in poc.lower() or "POST" in poc


# Audit Logging Tests

@pytest.mark.asyncio
async def test_exploit_audit_logged(exploit_agent, sqli_finding):
    """Test that all exploit actions are audit logged."""
    # Mock get_session to avoid database
    with patch('scanner.agents.exploit.get_session') as mock_session:
        mock_session.return_value.__aenter__.return_value = MagicMock()

        # Mock request_approval to auto-approve
        with patch('scanner.agents.exploit.request_approval') as mock_approval:
            mock_approval.return_value = (ApprovalDecision.APPROVE, {})

            await exploit_agent.execute([sqli_finding])

            # Verify audit was called for key events
            audit_calls = exploit_agent.audit.call_args_list
            event_types = [call[0][0] for call in audit_calls]

            # Should log: session start, chain suggested, steps, chain complete, session complete
            assert "exploit_session_start" in event_types
            assert "exploit_chain_suggested" in event_types
            assert "exploit_chain_complete" in event_types
            assert "exploit_session_complete" in event_types


# Integration Tests

@pytest.mark.asyncio
async def test_exploit_full_sqli_workflow(exploit_agent, sqli_finding):
    """Test complete SQLi exploitation workflow end-to-end."""
    # Mock approvals: approve first two steps, deny third
    approval_responses = [
        (ApprovalDecision.APPROVE, {}),  # Approve MODERATE step
        (ApprovalDecision.DENY, {})      # Deny DESTRUCTIVE step
    ]

    with patch('scanner.agents.exploit.get_session') as mock_session:
        mock_session.return_value.__aenter__.return_value = MagicMock()

        with patch('scanner.agents.exploit.request_approval') as mock_approval:
            mock_approval.side_effect = approval_responses

            results = await exploit_agent.execute([sqli_finding])

            assert len(results) == 1
            result = results[0]

            # Should execute SAFE step 1, MODERATE step 2, deny DESTRUCTIVE step 3
            assert result.steps_executed == 2
            assert result.steps_total == 3
            assert result.confidence == "confirmed"  # Has enough evidence
            assert result.evidence_validated is True
            assert result.poc is not None


@pytest.mark.asyncio
async def test_exploit_multiple_findings(exploit_agent, sqli_finding, xss_finding):
    """Test exploiting multiple findings in one session."""
    with patch('scanner.agents.exploit.get_session') as mock_session:
        mock_session.return_value.__aenter__.return_value = MagicMock()

        with patch('scanner.agents.exploit.request_approval') as mock_approval:
            mock_approval.return_value = (ApprovalDecision.APPROVE, {})

            results = await exploit_agent.execute([sqli_finding, xss_finding])

            assert len(results) == 2
            assert results[0].chain.finding == sqli_finding
            assert results[1].chain.finding == xss_finding


@pytest.mark.asyncio
async def test_exploit_modify_parameters(exploit_agent, sqli_finding):
    """Test that modified parameters are used in execution."""
    chain = await exploit_agent._suggest_chain(sqli_finding)
    step = chain.steps[1]  # MODERATE step

    # Mock approval to return MODIFY with different parameters
    modified_params = {"action": "enumerate", "target": "modified_schema"}

    with patch('scanner.agents.exploit.request_approval') as mock_approval:
        mock_approval.return_value = (ApprovalDecision.MODIFY, modified_params)

        with patch('scanner.agents.exploit.get_session') as mock_session:
            mock_session.return_value.__aenter__.return_value = MagicMock()

            # Mock _mock_tool_execution to capture parameters
            with patch.object(exploit_agent, '_mock_tool_execution') as mock_execute:
                mock_execute.return_value = {"status": "success", "raw_output": "test"}

                await exploit_agent._execute_step(step)

                # Verify modified parameters were used
                mock_execute.assert_called_once()
                call_params = mock_execute.call_args[0][1]
                assert call_params == modified_params
